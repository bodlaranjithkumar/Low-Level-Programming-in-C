//*********************************************************************************************************************************************************************
//
// Ranjith Kumar Bodla
// Advanced Operating Systems
// Programming Project #3_1: Robert and chang's algorithm
// Due date : 21 July 2014 Mon 6:00 p.m
// Instructor: Dr. Ajay K. Katangur
//
//*********************************************************************************************************************************************************************

#include <stdio.h>
#include <mpi.h>
#include <time.h>
#include <math.h>
#include <limits.h>

int main(int argc,char *argv[])
{
    	int rank,size,i;
	MPI_Status status;
    	MPI_Request request; 
	MPI_Init(&argc,&argv);             
    	MPI_Comm_rank(MPI_COMM_WORLD,&rank);
    	MPI_Comm_size(MPI_COMM_WORLD,&size);
	int PhaseNum=1,resultrcv,leadersnd =0;
	int randId=0,sendrandid=0,tagphase = 10, tagelected = 15;  
	int check=0,check2=0;	// flags
	char check1 = 'n';	//flag n = non participant, p = participant
    	int InputRank = atoi(argv[1]);	// rank starting the election
	int right = (rank+1)%size;	// rank left to current process
	int left = (size+rank-1)%size;	// rank on right to current process
	
	srand(time(NULL)+rank);// srand on time for null values + rank
	randId=random()%100000;	// genrating random number between 0 to 100000
 
	int value[size];	// ussing array to have all randid values in this array done by mpi_allgather by process intitiating election
	MPI_Allgather(&randId,1,MPI_INT,value,1,MPI_INT,MPI_COMM_WORLD);

if(size >3)
{
	if(rank==0)//rank 0 will print the all the random values generated by the process
	{
		printf("***************************************************\n");
		printf("Chang and Roberts Election Algorithm Implementation\n");
		printf("***************************************************\n");
    		for(i=0;i<size;i++)
	        {
	        	printf("Initial Rank : %d, Identifier : %d\n",i,value[i]);// print the random values
	        }
	}
	
    	if(rank==InputRank) 
	{
	        check1='n';
                MPI_Send(&randId,1,MPI_INT,right,tagphase,MPI_COMM_WORLD); // intital process sends its id to its right process
                printf("Processor %d is initiating the election and sending the number %d to processor %d\n",rank,randId,right);	        
	}
	
	while(1)
	{
	       MPI_Iprobe(left,tagphase,MPI_COMM_WORLD,&check,&status); // check = 1 if any process has sent else 0 for mpi probe
	       if(check==1) 	// checking if flag frmom mpi_prboe is 1
	       {
		        MPI_Recv(&sendrandid,1,MPI_INT,left,tagphase,MPI_COMM_WORLD,&status);
			if(check1=='n' && sendrandid == randId)	//	if process is not participant and it gets its initial sent value back then it is leader and sends elected message to all other process in a ring fashion
			{
		 	     leadersnd = 5;
                             MPI_Send(&leadersnd,1,MPI_INT,right,tagelected,MPI_COMM_WORLD);
                             printf ("Phase: %d, Rank: %d, Identifier: %d, Status: Active\n",PhaseNum,rank,randId);
                             printf("I am the Leader and my Rank is : %d and my Identifier is : %d\n",rank,randId);
			}
		         else if(check1=='n' && sendrandid >randId) // if process is not participant and its id is less than receivedid then status is passive
		         {
			          check1='p';	
			          MPI_Send(&sendrandid,1,MPI_INT,right,tagphase,MPI_COMM_WORLD);	
				  printf("Phase: %d, Rank: %d, Identifier: %d, Status: Passive\n",PhaseNum,rank,randId);
			 }
		         else if(check1=='n' && sendrandid<randId) // if process is not participant and its id is greater than receivedid then status is active
		         {
			           check1='p';
			           MPI_Send(&randId,1,MPI_INT,right,tagphase,MPI_COMM_WORLD);	
			 	   printf("Phase: %d, Rank: %d, Identifier: %d, Status: Active\n",PhaseNum,rank,randId);
		         }
			else if (check1=='p')	// to check if process is participant which is done in phase1
                         {
                                if(sendrandid == randId)	//check if participant's id is same as received id
                                {
                                     leadersnd = 5;	// some kind of acknowledgement as a status of leader elected
                                     PhaseNum++;	// increment phase
                                     MPI_Send(&leadersnd,1,MPI_INT,right,tagelected,MPI_COMM_WORLD);	//send elected message
                                     printf ("Phase: %d, Rank: %d, Identifier: %d, Status: Active\n",PhaseNum,rank,randId);
                                     printf("I am the Leader and my Rank is : %d and my Identifier is : %d\n",rank,randId);
                                 }
                                 if (sendrandid!=randId)	// received id is not equal to its id in phase 2
                                 {
                                       MPI_Send(&sendrandid,1,MPI_INT,right,tagphase,MPI_COMM_WORLD);
                                        PhaseNum++;

                                        if(sendrandid<randId)
                                                 printf("Phase: %d, Rank: %d, Identifier: %d, Status: Active\n",PhaseNum,rank,randId);
                                        else if(sendrandid > randId)
                                                 printf("Phase: %d, Rank: %d, Identifier: %d, Status: Passive\n",PhaseNum,rank,randId);
                                }
                         }
	       }
	
	       MPI_Iprobe(MPI_ANY_SOURCE,tagelected,MPI_COMM_WORLD,&check2,&status);	// probe used for leader elected message
	       if (check2==1)
	       {
 			   MPI_Recv(&resultrcv,1,MPI_INT,MPI_ANY_SOURCE,tagelected,MPI_COMM_WORLD,&status);//receive message from leader and then in a ring fashion
		           if (resultrcv == leadersnd) // if leader sends it message back then break the loop
				break;
		           if(resultrcv != leadersnd)	// pass the messge to process's right process about leader mesage
		           {
			        MPI_Send(&resultrcv,1,MPI_INT,right,tagelected,MPI_COMM_WORLD);
			        check1='n';
               			break;
		           }
		           
	       }
	}
	MPI_Finalize();
}
else	// to check if number of processes is not < 3
{
	if(rank == 0)
		printf("Number of processes executing cannot be less than 3\n");
	MPI_Finalize();
}
}
